{"ast":null,"code":"const {\n  Router\n} = require('next/router'); // initRouterListeners();\n\n\nexport function initRouterListeners() {\n  const routes = [];\n  Router.events.on('routeChangeStart', url => {\n    pushCurrentRouteInfo();\n  });\n  Router.events.on('routeChangeComplete', url => {\n    fixScrollPosition();\n  }); // Hack to set scrollTop because of this issue:\n  // - https://github.com/zeit/next.js/issues/1309\n  // - https://github.com/zeit/next.js/issues/3303\n\n  function pushCurrentRouteInfo() {\n    routes.push({\n      pathname: Router.pathname,\n      scrollY: window.scrollY\n    });\n  } // TODO: We guess we're going back, but there must be a better way\n  // https://github.com/zeit/next.js/issues/1309#issuecomment-435057091\n\n\n  function isBack() {\n    return routes.length >= 2 && Router.pathname === routes[routes.length - 2].pathname;\n  }\n\n  function fixScrollPosition() {\n    let scrollY = 0;\n\n    if (isBack()) {\n      routes.pop(); // route where we come from\n\n      const targetRoute = routes.pop(); // route where we return\n\n      scrollY = targetRoute.scrollY; // scrollY we had before\n    }\n\n    window.requestAnimationFrame(() => window.scrollTo(0, scrollY));\n  }\n}","map":{"version":3,"sources":["/home/anomy/Documents/nextjs-projects/yazbana/client/utils/scrollRestoration.js"],"names":["Router","require","initRouterListeners","routes","events","on","url","pushCurrentRouteInfo","fixScrollPosition","push","pathname","scrollY","window","isBack","length","pop","targetRoute","requestAnimationFrame","scrollTo"],"mappings":"AAAA,MAAM;AAAEA,EAAAA;AAAF,IAAaC,OAAO,CAAC,aAAD,CAA1B,C,CAEA;;;AAEA,OAAO,SAASC,mBAAT,GAA+B;AACpC,QAAMC,MAAM,GAAG,EAAf;AAEAH,EAAAA,MAAM,CAACI,MAAP,CAAcC,EAAd,CAAiB,kBAAjB,EAAsCC,GAAD,IAAS;AAC5CC,IAAAA,oBAAoB;AACrB,GAFD;AAIAP,EAAAA,MAAM,CAACI,MAAP,CAAcC,EAAd,CAAiB,qBAAjB,EAAyCC,GAAD,IAAS;AAC/CE,IAAAA,iBAAiB;AAClB,GAFD,EAPoC,CAWpC;AACA;AACA;;AAEA,WAASD,oBAAT,GAAgC;AAC9BJ,IAAAA,MAAM,CAACM,IAAP,CAAY;AAAEC,MAAAA,QAAQ,EAAEV,MAAM,CAACU,QAAnB;AAA6BC,MAAAA,OAAO,EAAEC,MAAM,CAACD;AAA7C,KAAZ;AACD,GAjBmC,CAmBpC;AACA;;;AACA,WAASE,MAAT,GAAkB;AAChB,WAAOV,MAAM,CAACW,MAAP,IAAiB,CAAjB,IAAsBd,MAAM,CAACU,QAAP,KAAoBP,MAAM,CAACA,MAAM,CAACW,MAAP,GAAgB,CAAjB,CAAN,CAA0BJ,QAA3E;AACD;;AAED,WAASF,iBAAT,GAA6B;AAC3B,QAAIG,OAAO,GAAG,CAAd;;AAEA,QAAIE,MAAM,EAAV,EAAc;AACZV,MAAAA,MAAM,CAACY,GAAP,GADY,CACE;;AACd,YAAMC,WAAW,GAAGb,MAAM,CAACY,GAAP,EAApB,CAFY,CAEsB;;AAClCJ,MAAAA,OAAO,GAAGK,WAAW,CAACL,OAAtB,CAHY,CAGmB;AAChC;;AAEDC,IAAAA,MAAM,CAACK,qBAAP,CAA6B,MAAML,MAAM,CAACM,QAAP,CAAgB,CAAhB,EAAmBP,OAAnB,CAAnC;AACD;AACF","sourcesContent":["const { Router } = require('next/router');\n\n// initRouterListeners();\n\nexport function initRouterListeners() {\n  const routes = [];\n\n  Router.events.on('routeChangeStart', (url) => {\n    pushCurrentRouteInfo();\n  });\n\n  Router.events.on('routeChangeComplete', (url) => {\n    fixScrollPosition();\n  });\n\n  // Hack to set scrollTop because of this issue:\n  // - https://github.com/zeit/next.js/issues/1309\n  // - https://github.com/zeit/next.js/issues/3303\n\n  function pushCurrentRouteInfo() {\n    routes.push({ pathname: Router.pathname, scrollY: window.scrollY });\n  }\n\n  // TODO: We guess we're going back, but there must be a better way\n  // https://github.com/zeit/next.js/issues/1309#issuecomment-435057091\n  function isBack() {\n    return routes.length >= 2 && Router.pathname === routes[routes.length - 2].pathname;\n  }\n\n  function fixScrollPosition() {\n    let scrollY = 0;\n\n    if (isBack()) {\n      routes.pop(); // route where we come from\n      const targetRoute = routes.pop(); // route where we return\n      scrollY = targetRoute.scrollY; // scrollY we had before\n    }\n\n    window.requestAnimationFrame(() => window.scrollTo(0, scrollY));\n  }\n}\n"]},"metadata":{},"sourceType":"module"}